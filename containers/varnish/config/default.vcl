vcl 4.0;

import std;
import directors;

# Import modules
include "includes/imports.vcl";

# Import file with probe definitions
include "includes/probes.vcl";

# Import file with backend definitions
include "includes/backends.vcl";

# Import file with acl definitions
include "includes/acls.vcl";

sub vcl_init {
	# Import file with director definitions;
	include "includes/directors.vcl";
}

sub vcl_recv {
	# https://info.varnish-software.com/blog/blog-sysadmin-monitoring-health-varnish-cache
	if (req.method == "GET" && req.url == "/health") {
		return(synth(200, "health"));
	}

	# Remove tracking parameter from url and normalize query arguments
	include "includes/cache_hitrate_booster.vcl";

	# Shopware: Set a header announcing Surrogate Capability to the origin
	set req.http.Surrogate-Capability = "shopware=ESI/1.0";

	set req.http.X-Varnish-Esi-Level = req.esi_level;

	# Extract real client ip from X-Forwarded-For header. We do trust X-Forwarded-For header here as it is generated by
	# nginx and any client supplied value is removed.
	if (req.http.X-Real-Ip) {
		set req.http.X-Client-Ip = req.http.X-Real-Ip;
	} elseif (req.http.X-Forwarded-For) {
		set req.http.X-Client-Ip = regsub(req.http.X-Forwarded-For, "[, ].*$", "");
	} else {
		set req.http.X-Client-Ip = client.ip;
	}

	# backend selection logic
	include "includes/backendselection.vcl";

	unset req.http.X-Restart-After-Purge;

	if (req.method == "BAN") {
		if (!std.ip(req.http.X-Client-Ip, client.ip) ~ purge) {
			return (synth(405, "Not allowed."));
		}

		set req.http.Host = regsub(req.http.host, ":\d+$", "");

		# TYPO3/Neos: Cache Tags
		if (req.http.X-Cache-Tags) {
			ban("obj.http.X-Cache-Tags ~ " + req.http.X-Cache-Tags);
		}
		# Shopware: Cache Tags
		elsif (req.http.X-Shopware-Invalidates) {
			ban("obj.http.X-Shopware-Cache-Id ~ " + ";" + req.http.X-Shopware-Invalidates + ";");
			return (synth(200, "BAN of content connected to the X-Shopware-Cache-Id (" + req.http.X-Shopware-Invalidates + ") done."));
		}
		# Neos: Flush cache by url
		elseif (req.http.X-Site && req.http.X-Host && req.http.X-Url) {
			ban("obj.http.X-Host ~ " + req.http.X-Host
				+ " && obj.http.X-Url ~ " + req.http.X-Url
				+ " && obj.http.X-Site ~ " + req.http.X-Site
			);
		} else {
			ban("obj.http.x-url ~ " + req.url + " && obj.http.x-host == " + req.http.Host);
		}
		return (synth(200, "Ban added."));
	}

	if (req.method == "PURGE") {
		if (!std.ip(req.http.X-Client-Ip, client.ip) ~ purge) {
			return (synth(405, "Not allowed."));
		}
		set req.http.Host = regsub(req.http.host, ":\d+$", "");
		return (purge);
	}

	if (std.healthy(req.backend_hint)) {
		set req.grace = 30s;
	} else {
		set req.grace = 24h;
	}

	# parse accept encoding rulesets to normalize
	if (req.http.Accept-Encoding) {
		if (req.http.Accept-Encoding ~ "gzip") {
			set req.http.Accept-Encoding = "gzip";
		} elseif (req.http.Accept-Encoding ~ "deflate") {
			set req.http.Accept-Encoding = "deflate";
		} else {
			# unkown algorithm
			unset req.http.Accept-Encoding;
		}
	}

	if (req.method == "PRI") {
		/* We do not support SPDY or HTTP/2.0 */
		return (synth(405));
	}

	if (!req.http.host &&
		req.esi_level == 0 &&
		req.proto ~ "^(?i)HTTP/1.1") {
		/* In HTTP/1.1, Host is required. */
		return (synth(400));
	}

	if (req.method != "GET" &&
		req.method != "HEAD" &&
		req.method != "PUT" &&
		req.method != "POST" &&
		req.method != "TRACE" &&
		req.method != "OPTIONS" &&
		req.method != "DELETE" &&
		req.method != "PATCH") {
		/* Non-RFC2616 or CONNECT which is weird. */
		return (pipe);
	}

	# We only deal with GET and HEAD by default
	if (req.method != "GET" && req.method != "HEAD") {
		return (pass);
	}

	# Detect backend user by different cookies
	if (req.http.Cookie ~ "\bbe_typo_user=") {
		set req.http.X-Is-Backend-User-Authenticated = "true";
	} elseif (req.http.Cookie ~ "\bNeos_Session=") {
		set req.http.X-Is-Backend-User-Authenticated = "true";
	} elseif (req.http.Cookie ~ "\bSHOPWAREBACKEND=") {
		set req.http.X-Is-Backend-User-Authenticated = "true";
	} else {
		unset req.http.X-Is-Backend-User-Authenticated;
	}

	# Purge varnish when force reloading the page and backend user is detected
	if (req.restarts == 0 && req.http.Cache-Control ~ "no-cache" && req.http.X-Is-Backend-User-Authenticated) {
		set req.http.X-Restart-After-Purge = 1;
		return (purge);
	}

	include "includes/recv.vcl";

	# Shopware: Don't cache selfhealing-redirect
	if (req.http.Cookie ~ "ShopwarePluginsCoreSelfHealingRedirect") {
		return (pass);
	}

	# Shopware: Always pass these paths directly to php without caching
	# Note: virtual URLs might bypass this rule (e.g. /en/checkout)
	if (req.url ~ "^/(checkout|account)(/.*)?$") {
		return (pass);
	}

	# TYPO3: Always pass EXT:solr indexing requests
	if (req.http.X-Tx-Solr-Iq && std.ip(req.http.X-Client-Ip, client.ip) ~ webserver) {
		return (pass);
	}

	# don't cache for TYPO3, Shopware, Neos backend
	if (req.url ~ "^/(typo3|backend|neos|_token-login)(/.*)?$") {
		return (pass);
	}

	# TYPO3: Admin panel should work
	if (req.url ~ "TSFE_ADMIN_PANEL") {
		return (pass);
	}

	# video streaming must be in pipe to work
	if (req.url ~ "\.(?:mp4|webm)$") {
		return (pipe);
	}

	return (hash);
}


sub vcl_backend_response {
	set beresp.http.x-url = bereq.url;
	set beresp.http.x-host = bereq.http.host;

	# Allow 24hour stale content, before an error 500/404 is thrown
	set beresp.grace = 24h;

	include "includes/backend_response_pre_cookie_unset.vcl";

	# Clean up cookies, we normally don't need session cookies
	# FIXME: we need to check, whether we still have to fight unnecessary cookies or if nowadays TYPO3 and Neos set cookies responsibly
#	if (beresp.http.Set-Cookie) {
#		if (!(beresp.http.Set-Cookie ~ "\b(?:be_typo_user|Typo3InstallTool|PHPSESSID|SHOPWAREBACKEND)=" || bereq.url ~ "^/neos" || bereq.url ~ "^/_token-login" || beresp.http.X-Allow-Cookie)) {
#			unset beresp.http.Set-Cookie;
#		}
#	}
	unset beresp.http.X-Allow-Cookie;

	# ESI requests returning an error should not return the error page (possibly containing esi tags in the error document)
	if (beresp.status >= 400 && bereq.http.X-Varnish-Esi-Level && std.integer(bereq.http.X-Varnish-Esi-Level, 0) > 0) {
		return (abandon);
	}

	# Respect force-reload, and clear cache accordingly. This means that a ctrl-reload will actually purge
	# the cache for this URL with backend user.
	if (bereq.http.Cache-Control ~ "no-cache" && bereq.http.X-Is-Backend-User-Authenticated) {
		set beresp.http.X-Cacheable = "NO: force-reload with backend user";
		set beresp.ttl = 0s;
	} elseif (beresp.http.X-Is-Static-File) {
		unset beresp.http.Set-Cookie;
		set beresp.http.X-Cacheable = "YES: static files are always cached";

		if (beresp.status == 200) {
			# Cache in varnish for one week if not told otherwise
			if (beresp.ttl <= 0s) {
				set beresp.ttl = 1w;
			}

			# Long cache lifetime for versioned files
			# TYPO3 processed files and assets
			if (bereq.url ~ "/_processed_/|^/typo3temp/assets/") {
				set beresp.http.cache-control = "public, max-age=31536000";
			}
			# Neos persistent Resource
			elseif (bereq.url ~ "^/_Resources/Persistent/(?:[a-f0-9]/[a-f0-9]/[a-f0-9]/[a-f0-9]/)?[a-f0-9]{40}/") {
				set beresp.http.cache-control = "public, max-age=31536000";
			}
			# Stencil js files in Public "Build" folder of TYPO3 extension or Neos package
			elseif (bereq.url ~ "^/(?:typo3conf/ext/.*/Resources/Public|_Resources/Static/Packages/[a-zA-Z0-9.]+)/Build/[a-zA-Z0-9._/-]+[._/-][a-z0-9]{8}(\.es5|\.entry)?\.js$") {
				set beresp.http.cache-control = "public, max-age=31536000";
			}
			# Check query string for patterns like ${timestamp} or v=${versionNumber} or bust=${hash} or ${hash}
			elseif (bereq.url ~ "\?(?:(?:\d+|v=[\d.]+|bust=[a-z0-9]{8}|[a-z0-9.-]+)(?:&|$))+$") {
				set beresp.http.cache-control = "public, max-age=31536000";
			}
			# Check if filename contains a timestamp in the filename
			elseif (bereq.url ~ "\.[0-9]{10}\.[a-z0-9]+$") {
				set beresp.http.cache-control = "public, max-age=31536000";
			}
			# Shopware files, statically cacheable
			elseif (bereq.url ~ "/media/(archive|banner|image|music|pdf|unknown|video)/[a-zA-Z0-9_/-]+\.(jpe?g|png|webp|gif|svg|pdf)$") {
				set beresp.http.cache-control = "public, max-age=31536000";
			}
			# Use custom cache life time for example when caching the sitemap.xml for only 5m
			elseif (beresp.ttl < 1h) {
				set beresp.http.cache-control = "public, max-age=" + regsub(beresp.ttl, "\..*$", "");
			}
			# Fallback to minimum cache lifetime of 1h
			else {
				set beresp.http.cache-control = "public, max-age=3600";
			}
		}

		unset beresp.http.Expires;
		unset beresp.http.Pragma;
		set beresp.http.X-Set-Age-Zero = "true";

		# Don't cache file larger than 10MB
		if (beresp.http.Content-Length ~ "[0-9]{8,}") {
			set beresp.http.X-Cacheable = "NO: file too large";
			set beresp.ttl = 1w;
			set beresp.uncacheable = true;
		}

		return (deliver);
	}

	include "includes/backend_response_post_static_file_caching.vcl";

	# Allow edgeside includes
	set beresp.do_esi = true;
	unset beresp.http.Surrogate-Control;

	# Since we rely on backend to send the correct Cache-control headers, we do nothing except for removing the cache-control headers before output

	# Handle Cache-Control private/no-cache/no-store headers
	if (beresp.http.Cache-Control ~ "(?i:no-cache|no-store|private)") {
		set beresp.ttl = 0s;
	}

	# Make sure that we unset all cache headers, so the browser does not cache it for us!
	unset beresp.http.Cache-Control;
	unset beresp.http.Pragma;
	unset beresp.http.Expires;
	unset beresp.http.Last-Modified;
	unset beresp.http.ETag;

	if (!beresp.http.X-Cacheable) {
		set beresp.http.X-Cacheable = "NO";
		if (beresp.ttl > 0s) {
			set beresp.http.X-Cacheable = "YES";
		}
	}

	if (beresp.http.Set-Cookie) {
		set beresp.http.X-Cacheable = "NO: Set-Cookie header present";
		set beresp.ttl = 0s;
	}

	# Set TTL as header for debugging
	set beresp.http.X-Cache-TTL = beresp.ttl;

	# Make sure a lot of requests to uncached pages do not yam too much
	if (beresp.ttl <= 0s) {
		set beresp.ttl = 10s;
		set beresp.http.Cache-Control = "private";
		set beresp.uncacheable = true;
	}

	# Don't cache file larger than 10MB
	if (beresp.http.Content-Length ~ "[0-9]{8,}") {
		set beresp.http.X-Cacheable = "NO: file too large";
		set beresp.ttl = 1w;
		set beresp.uncacheable = true;
	}

	return (deliver);
}

sub vcl_hash {
	include "includes/hash.vcl";
	## normalize shop and currency cookie in hash to improve hitrate
	if (req.http.cookie ~ "shop=") {
		hash_data("+shop=" + regsub(req.http.cookie, "^.*?shop=([^;]*);*.*$", "\1"));
	} else {
		hash_data("+shop=1");
	}

	if (req.http.cookie ~ "currency=") {
		hash_data("+currency=" + regsub(req.http.cookie, "^.*?currency=([^;]*);*.*$", "\1"));
	} else {
		hash_data("+currency=1");
	}

	if (req.http.cookie ~ "x-cache-context-hash=") {
		hash_data("+context=" + regsub(req.http.cookie, "^.*?x-cache-context-hash=([^;]*);*.*$", "\1"));
	}
}

sub vcl_hit {
	include "includes/hit.vcl";
	if (obj.http.X-Shopware-Allow-Nocache && req.http.cookie ~ "nocache=") {
		if (obj.http.X-Shopware-Allow-Nocache && req.http.cookie ~ "slt=") {
			set req.http.X-Cookie-Nocache = regsub(req.http.Cookie, "^.*?nocache=([^;]*);*.*$", "\1, slt");
		} else {
			set req.http.X-Cookie-Nocache = regsub(req.http.Cookie, "^.*?nocache=([^;]*);*.*$", "\1");
		}
		if (std.strstr(req.http.X-Cookie-Nocache, obj.http.X-Shopware-Allow-Nocache)) {
			return (pass);
		}
	}
}

sub vcl_miss {
	include "includes/miss.vcl";
}

sub vcl_backend_fetch {
	include "includes/backend_fetch.vcl";
	if (bereq.method == "GET") {
		unset bereq.body;
	}

	# range requests may have response code 206 which are not handled properly by varnish
	if (bereq.http.Range) {
		unset bereq.http.Range;
	}
}

sub vcl_deliver {
	# For static files, the browser should always get Age: 0 to cache it as long as possible
	if (resp.http.X-Set-Age-Zero) {
		unset resp.http.X-Set-Age-Zero;

		# By definition we have a fresh object
		set resp.http.age = "0";
	}

	unset resp.http.x-url;
	unset resp.http.x-host;

	# remove link header, if session is already started to save client resources
	if (req.http.cookie ~ "session-") {
		unset resp.http.Link;
	}

	if (!std.ip(req.http.X-Client-Ip, client.ip) ~ debug) {
		unset resp.http.X-Cacheable;
		unset resp.http.X-Cache-Tags;
		unset resp.http.X-Cache-TTL;
		unset resp.http.X-Is-Static-File;
		unset resp.http.X-Site;

		# Shopware: unset the headers, thus remove them from the response the client sees
		unset resp.http.X-Shopware-Allow-Nocache;
		unset resp.http.X-Shopware-Cache-Id;
	} elseif (obj.hits > 0) {
		set resp.http.X-Cache = "HIT";
		set resp.http.X-Cache-Hits = obj.hits;
	} else {
		set resp.http.X-Cache = "MISS";
	}

	include "includes/deliver.vcl";

	return (deliver);
}

sub vcl_purge {
	if (req.http.X-Restart-After-Purge) {
		return (restart);
	}
}

sub vcl_backend_error {
	# ESI requests returning an error should not return the error page (possibly containing esi tags in the error document)
	if (bereq.http.X-Varnish-Esi-Level && std.integer(bereq.http.X-Varnish-Esi-Level, 0) > 0) {
		set beresp.http.Content-Type = "text/html; charset=utf-8";
		synthetic("");
		set beresp.ttl = 0s;
		return (deliver);
	}
}

sub vcl_synth {
	if (req.http.X-Varnish-Esi-Level && std.integer(req.http.X-Varnish-Esi-Level, 0) > 0) {
		set resp.http.Content-Type = "text/html; charset=utf-8";
		synthetic("");
		return (deliver);
	}

	include "includes/synth.vcl";
}
